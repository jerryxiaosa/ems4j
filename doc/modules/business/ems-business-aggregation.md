# ems-business-aggregation 模块作用与使用规范

## 模块定位

`ems-business-aggregation` 是跨业务模块的读聚合模块，负责在查询场景下对多个业务模块的数据进行编排、拼装和轻量规则计算。

当前模块的首个落地场景是：账户列表展示电费余额聚合（账户模块列表 + 财务余额数据）。

## 设计目标

1. 将跨业务的查询拼装逻辑从 `ems-web` 下沉，避免 Web 编排层承担领域规则。
2. 优先采用简单、通用、可维护的 SQL 语句，降低数据库迁移成本。
3. 为后续跨业务复杂搜索预留只读 join 查询能力，但避免滥用。

## 职责边界

### 应该做的事

1. 调用多个业务模块服务进行批量查询与结果聚合。
2. 处理展示层所需的轻量计算规则（例如余额来源选择、数量统计整合）。
3. 在无法通过服务拼装满足“筛选/排序/分页准确性”时，提供只读 join 查询能力。

### 不应该做的事

1. 不处理跨业务写入逻辑，不做事务编排写操作。
2. 不绕过业务模块长期直接操作其写模型表作为常规方案。
3. 不沉淀复杂数据库方言 SQL（窗口函数、CTE、专有函数等）作为默认实现。
4. 不把模块做成通用 DAO 或第二套业务核心服务。

## 查询实现优先级（必须遵循）

1. `优先`：调用业务模块服务 + Java 聚合（默认方式）
2. `其次`：aggregation 模块内简单 join 查询（仅限只读、且拼装无法满足需求）
3. `最后`：当 join 查询持续复杂化时，升级为“查询表 / 读模型”方案

## SQL 规范（朴素 SQL 原则）

允许使用：

1. `SELECT ... FROM ... WHERE ...`
2. `IN (...)`
3. `LEFT JOIN / INNER JOIN`
4. `GROUP BY`
5. `SUM / COUNT / MAX / MIN`
6. `ORDER BY`
7. `LIMIT`

默认避免使用：

1. `CASE WHEN`（除非确有必要且经评审确认）
2. 窗口函数
3. CTE（`WITH`）
4. 数据库方言函数
5. JSON 函数
6. 多层嵌套子查询

## 跨业务 join 查询的准入条件

仅在满足以下任一条件时，才允许在 aggregation 模块新增 join 查询：

1. 需要跨业务字段联合筛选，且必须在分页前完成
2. 需要跨业务字段联合排序，且必须数据库排序
3. 服务拼装会导致分页结果不准确
4. 服务拼装性能明显不可接受

## 跨业务 join 查询约束

1. 只读查询，禁止写操作。
2. 禁止 `select *`，必须显式列名。
3. SQL 尽量保持 MySQL / H2 通用。
4. 单条 SQL 的 join 表数量应保持克制（建议先控制在 3 张以内）。
5. 当 SQL 可读性明显下降时，应转为“查询表 / 读模型”方案，而不是继续堆 SQL。

## 当前已落地能力（阶段1）

1. `AccountElectricBalanceAggregateService`
2. 账户列表展示电费余额聚合（输入项使用账户计费类型 `ElectricAccountTypeEnum`；通过 `ems-business-finance` 的 `BalanceService.findListByAccountIds` 获取余额明细，再由 aggregation 模块进行 Java 聚合）

## 演进建议

1. 当账户列表性能不足时，可在财务模块补充简单聚合查询接口（仍保持朴素 SQL），由 aggregation 模块调用。
2. 当出现复杂跨业务搜索且 join SQL 变重时，建设查询表/读模型并由 aggregation 统一查询。
